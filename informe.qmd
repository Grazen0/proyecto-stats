---
title: Estadística y probabilidades - PG1
author:
  - José Daniel Grayson Tejada (líder)
  - Fali Ferdinand Araoz Arana
  - Leisy Valeska Bendezu Choque
  - Daniela Landavery Vergaray
  - Vincenzo Francisco Magnani Castro
lang: es
editor: visual
toc: true
toc-depth: 4
format: html
---

## Objetivos

El objetivo principal de este proyecto es conocer los factores que influyen en la aceptación de una cuenta de ahorro vía telefónica para los clientes de una entidad bancaria a través de la identificación de patrones usando el análisis estadístico.

Dentro de este marco general, nuestro grupo considera los siguientes objetivos específicos:

1. Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.
2. Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.
3. Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.
4. Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.
5. Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.

Cabe destacar que en todos estos objetivos se hace presente la variable `adq_ahorro` como la variable dependiente que queremos analizar.

## Limpieza de datos

Primero, cargamos las librerías que usaremos para limpiar los datos.

```{r}
#| output: false

if (!require("tidyverse")) install.packages("tidyverse")
if (!require("modeest")) install.packages("modeest")
if (!require("knitr")) install.packages("knitr")

library("tidyverse") # `dplyr` viene con tidyverse
library("modeest")
library("knitr")
```

Ahora, leemos el CSV con los datos y mostramos un breve vistazo con las primeras 12 observaciones:

```{r}
df <- read_csv("AdquisicionAhorro.csv")
kable(df[1:12, ])
```

En total, esta tabla tiene `r ncol(df)` columnas (es decir, variables) y `r nrow(df)` filas (es decir, observaciones).

Con análisis manual, podemos clasificar a las variables que esta tabla contiene:

| Variable     | Tipo         | Sub-tipo |
| ------------ | ------------ | -------- |
| `coddoc`     | cualitativa  | nominal  |
| `edad`       | cuantitativa | discreta |
| `estciv`     | cualitativa  | nominal  |
| `educacion`  | cualitativa  | nominal  |
| `mora`       | cualitativa  | nominal  |
| `balance`    | cuantitativa | continua |
| `vivienda`   | cualitativa  | nominal  |
| `prestamo`   | cualitativa  | nominal  |
| `dia`        | cuantitativa | discreta |
| `duracion`   | cuantitativa | discreta |
| `campana`    | cuantitativa | discreta |
| `pdias`      | cuantitativa | discreta |
| `previo`     | cuantitativa | discreta |
| `adq_ahorro` | cualitativa  | nominal  |

:::{.callout-important}
Nótese que, a lo largo de este documento, clasificamos a `adq_ahorro` como categórico porque es esencialmente un sí/no codificado como 1/0.
:::

### Transformación de datos

Como paso preliminar, renombraremos la última columna de `df` para tener consistencia entre los nombres de todas las columnas:

```{r}
if ("Adq_Ahorro" %in% colnames(df))
  df <- df %>% rename(adq_ahorro = Adq_Ahorro)
```

#### Eliminación de variables innecesarias

Acorde con los objetivos establecidos, conservaremos únicamente las siguientes variables:

- `edad`
- `estciv`
- `educacion`
- `mora`
- `balance`
- `campana`
- `pdias`
- `adq_ahorro`

```{r}
df <- df %>% select(edad, estciv, educacion, mora, balance, campana, pdias, adq_ahorro)
```

#### Arreglo del tipo de `balance`

Podemos observar que la columna `balance` no es de tipo numérico (como debería de ser), sino que es de tipo carácter. Esto significa que existe algún dato en `balance` que no es un valor numérico válido.

Ante ello, podemos usar la función `as.numeric` para convertir a la fuerza los datos de `balance` a números. Los que no se puedan convertir correctamente se convertirán en `NA`, con lo cual se lidiará al tratar con los datos faltantes.

```{r}
df$balance <- as.numeric(df$balance)
```

En efecto, podemos comprobar que la columna `balance` ahora es de tipo numérico:

```{r}
typeof(df$balance)
```

### Tratamiento de datos faltantes

Un chequeo rápido hace notar que la mayoría de variables contienen algunos datos faltantes:

```{r}
colSums(is.na(df))
```

En total, esto constituye `r sum(is.na(df))` datos faltantes, lo cual es aproximadamente un `r round(100 * sum(is.na(df)) / (ncol(df) * nrow(df)))`% del total de `r ncol(df) * nrow(df)` datos presentes en la tabla.

En términos de observaciones en general, los datos contienen `r sum(!complete.cases(df))` observaciones con algún dato faltante, lo cual es un `r round(100 * sum(!complete.cases(df)) / nrow(df))`% del total.

#### Imputación de datos

##### Variables categóricas

Para las variables categóricas, imputaremos como reemplazo a los datos faltantes la **moda** de los datos existentes.

```{r}
# Esta función calcula la moda de una lista de datos `x`
# y la imputa en sus valores faltantes.
input_mode <- function(x) replace_na(x, mfv(x))

df$estciv <- input_mode(df$estciv)
df$educacion <- df$educacion %>%
  input_mode() %>%
  replace(df$educacion == "desconocido", mfv(df$educacion))
df$mora <- input_mode(df$mora)
```

::: {.callout-note}
Nótese que en la columna `educacion` imputamos también sobre las celdas que contienen `"desconocido"`, ya que, para propósitos de este proyecto, representan exactamente lo mismo que un `NA`: el dato no se conoce.
:::

Esta imputación no se realiza en `adq_ahorro` por dos razones:

1. `adq_ahorro` en realidad no tiene datos faltantes.
2. `adq_ahorro` es la variable dependiente del análisis. Queremos encontrar cómo se relaciona con el resto de variables que tenemos, así que no sería de ayuda que tenga datos no reales.

##### Variables numéricas

Para las variables numéricas, consideramos dos métodos de imputación: la **media** y la **mediana**. La selección de la medida a usar para imputar los datos faltantes se hará según el coeficiente de variación.

```{r}
# Esta función calcula el coeficiente de variación de `x`
# ignorando los NAs
cv <- function(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)

cvs <- apply(df %>% select(edad, balance, campana), 2, cv)
cvs
```

El criterio que usaremos es el siguiente:

- Si $\text{CV} < 30\%$, entonces se imputará la **media**, ya que los datos son homogéneos.
- Si $\text{CV} \geq 30\%$, entonces se imputará la **mediana**, ya que los datos se inclinan más hacia ser heterogéneos.

Realizamos este criterio con el objetivo de imputar la medida que mejor represente a cada variable: sabemos que la media es más representativa cuando la dispersión es baja, mientras que, caso contrario, la mediana es más representativa.

Además, si la variable imputada debe ser discreta, el valor de reemplazo se redondea al entero más cercano.

```{r}
is.discrete <- function(x) {
  all(x == as.integer(x), na.rm = TRUE)
}

for (colname in names(cvs)) {
  x <- df[[colname]]

  x_mean = mean(x, na.rm = TRUE)
  x_median = median(x, na.rm = TRUE)

  # Si CV < 0.3, usar la media; sino, la mediana
  replace_value <- ifelse(cvs[[colname]] < 0.3, x_mean,  x_median)

  if (is.discrete(x))
    replace_value <- round(replace_value)

  df[[colname]] <- replace_na(x, replace_value)
}
```

#### Eliminación de observaciones

La particularidad de la columna `pdias` de poder incluir valores `-1` (nulos) podría dificultar la decisión sobre qué valor imputar a sus datos faltantes. Sin embargo, en esta base de datos particular, `pdias` sólo tiene un valor faltante, por lo que podemos optar por simplemente eliminar dicha observación completamente.

```{r}
df <- df %>% filter(!is.na(df$pdias))
```

### Comprobaciones finales

#### Búsqueda de datos atípicos

Para las variables numéricas, es prudente comprobar que la data no salga de rangos realistas (no debería haber alguna edad, por ejemplo, de 200 años).

```{r}
summary(df %>% select(edad, balance, campana, pdias))
```

La columna `edad` presenta un rango aceptable: de `r min(df$edad)` a `r max(df$edad)` años.

La columna `balance`, por su máximo, podría levantar sospechas. Sin embargo, un diagrama de caja ayuda a visualizar que que la mayoría de datos se encuentran alrededor de la mediana: `r median(df$edad)` euros.

```{r}
boxplot(df$balance, main = "Balance promedio anual")
```

Se aprecia que el valor máximo de `balance` es un valor atípico, y considerando lo alejado que está del resto, consideramos que es completamente posible y no debería ser eliminado.

La columna `campana` también podría levantar sospechas, pero su diagrama de caja nos facilita una conclusión similar a la anterior:

```{r}
boxplot(df$campana, main = "Número de contactos realizados durante la campaña")
```

El máximo de `campana`, aunque es comparablemente alto al resto, es posible en la vida real.

Finalmente, el `pdias` se debe hacer por separado ya que, como muestra su `summary`, está tomando en cuenta a los `-1`s, los cuales, más que un valor numérico real, son un código para un valor "nulo".

Por ello, conviene hacer un `summary` de `pdias` ignorando sus valores `-1`:

```{r}
summary(df$pdias[df$pdias != -1])
```

Ocurre un caso similar a los anteriores.

```{r}
boxplot(df$pdias, main = "Días desde el último contacto al cliente")
```

La mayoría de los datos de `pdias` se encuentran alrededor de la mediana, `r median(df$pdias[df$pdias != -1])`, mientras que los más altos o bien son pocos, o en cualquier caso son posibles en la vida real.

#### Consistencia de las variables categóricas

Finalmente, es preciso comprobar que las variables categóricas tienen valores consistentes. Por ejemplo, la columna `estciv`, ya que contiene al menos los valores `"married"`, `"single"` y `"divorced"`, no debería contener versiones alternativas de estos, como por ejemplo `"Married"` o `"SINGLE"`.

Podemos comprobar los valores presentes en cada una de estas variables con la función `unique`:

```{r}
apply(df %>% select(estciv, educacion, mora, adq_ahorro), 2, unique)
```

De esta manera, podemos comprobar que las variables categóricas tienen valores consistentes.

### Resultado final

Mostramos a continuación un vistazo al resultado de la base de datos tras la limpieza:

```{r}
summary(df)
kable(df[1:12, ])
```

Además, podemos comprobar que está libre de datos faltantes:

```{r}
colSums(is.na(df))
```
