---
title: Estadística y probabilidades - PG1
author:
  - José Daniel Grayson Tejada (líder)
  - Fali Ferdinand Araoz Arana
  - Leisy Valeska Bendezu Choque
  - Daniela Landavery Vergaray
  - Vincenzo Francisco Magnani Castro
lang: es
editor: visual
toc: true
format:
  html:
    toc: true
    toc-depth: 4
embed-resources: true
---

## Objetivos

El objetivo principal de este proyecto es conocer los factores que influyen en la aceptación de una cuenta de ahorro vía telefónica para los clientes de una entidad bancaria a través de la identificación de patrones usando el análisis estadístico.

Dentro de este marco general, nuestro grupo considera los siguientes objetivos específicos:

1. Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.
2. Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.
3. Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.
4. Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.
5. Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.

Cabe destacar que en todos estos objetivos se hace presente la variable `adq_ahorro` como la variable dependiente que queremos analizar.

## Limpieza de datos

```{r}
cv <- function(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
is.discrete <- function(x) all(x == as.integer(x), na.rm = TRUE)
ran <- function(x) max(x) - min(x)
```

Primero, cargamos las librerías que usaremos para limpiar los datos.

```{r}
#| output: false

if (!require("tidyverse")) install.packages("tidyverse")
if (!require("modeest")) install.packages("modeest")
if (!require("knitr")) install.packages("knitr")
if (!require("ggplot2")) install.packages("ggplot2")

library("tidyverse") # `dplyr` viene con tidyverse
library("modeest")
library("knitr")
```

Ahora, leemos el CSV con los datos y mostramos un breve vistazo con las primeras 12 observaciones:

```{r}
df <- read_csv("AdquisicionAhorro.csv")
kable(df[1:12, ])
```

En total, esta tabla tiene `r ncol(df)` columnas (es decir, variables) y `r nrow(df)` filas (es decir, observaciones).

Con análisis manual, podemos clasificar a las variables que esta tabla contiene:

| Variable     | Tipo         | Sub-tipo |
| ------------ | ------------ | -------- |
| `coddoc`     | cualitativa  | nominal  |
| `edad`       | cuantitativa | discreta |
| `estciv`     | cualitativa  | nominal  |
| `educacion`  | cualitativa  | nominal  |
| `mora`       | cualitativa  | nominal  |
| `balance`    | cuantitativa | continua |
| `vivienda`   | cualitativa  | nominal  |
| `prestamo`   | cualitativa  | nominal  |
| `dia`        | cuantitativa | discreta |
| `duracion`   | cuantitativa | discreta |
| `campana`    | cuantitativa | discreta |
| `pdias`      | cuantitativa | discreta |
| `previo`     | cuantitativa | discreta |
| `adq_ahorro` | cualitativa  | nominal  |

:::{.callout-important}
Nótese que, a lo largo de este documento, clasificamos a `adq_ahorro` como categórico porque es esencialmente un sí/no codificado como 1/0.
:::

### Transformación de datos

Como paso preliminar, renombraremos la última columna de `df` para tener consistencia entre los nombres de todas las columnas:

```{r}
if ("Adq_Ahorro" %in% colnames(df))
  df <- df %>% rename(adq_ahorro = Adq_Ahorro)
```

#### Eliminación de variables innecesarias

Acorde con los objetivos establecidos, conservaremos únicamente las siguientes variables:

- `edad`
- `estciv`
- `educacion`
- `mora`
- `balance`
- `campana`
- `pdias`
- `adq_ahorro`

```{r}
df <- df %>% select(edad, estciv, educacion, mora, balance, campana, pdias, adq_ahorro)
```

#### Arreglo del tipo de `balance`

Podemos observar que la columna `balance` no es de tipo numérico (como debería de ser), sino que es de tipo carácter. Esto significa que existe algún dato en `balance` que no es un valor numérico válido.

Ante ello, podemos usar la función `as.numeric` para convertir a la fuerza los datos de `balance` a números. Los que no se puedan convertir correctamente se convertirán en `NA`, con lo cual se lidiará al tratar con los datos faltantes.

```{r}
df$balance <- as.numeric(df$balance)
```

En efecto, podemos comprobar que la columna `balance` ahora es de tipo numérico:

```{r}
typeof(df$balance)
```

### Tratamiento de datos faltantes

Un chequeo rápido hace notar que la mayoría de variables contienen algunos datos faltantes:

```{r}
colSums(is.na(df))
```

En total, esto constituye `r sum(is.na(df))` datos faltantes, lo cual es aproximadamente un `r round(100 * sum(is.na(df)) / (ncol(df) * nrow(df)))`% del total de `r ncol(df) * nrow(df)` datos presentes en la tabla.

En términos de observaciones en general, los datos contienen `r sum(!complete.cases(df))` observaciones con algún dato faltante, lo cual es un `r round(100 * sum(!complete.cases(df)) / nrow(df))`% del total.

#### Imputación de datos

##### Variables categóricas

Para las variables categóricas, imputaremos como reemplazo a los datos faltantes la **moda** de los datos existentes.

```{r}
# Esta función calcula la moda de una lista de datos `x`
# y la imputa en sus valores faltantes.
input_mode <- function(x) replace_na(x, mfv(x))

df$estciv <- replace_na(df$estciv, mfv(df$estciv))
df$educacion <- replace(df$educacion, is.na(df$educacion) | df$educacion == "desconocido", mfv(df$educacion))
df$mora <- replace_na(df$mora, mfv(df$mora))
```

::: {.callout-note}
Nótese que en la columna `educacion` imputamos también sobre las celdas que contienen `"desconocido"`, ya que, para propósitos de este proyecto, representan exactamente lo mismo que un `NA`: el dato no se conoce.
:::

Esta imputación no se realiza en `adq_ahorro` por dos razones:

1. `adq_ahorro` en realidad no tiene datos faltantes.
2. `adq_ahorro` es la variable dependiente del análisis. Queremos encontrar cómo se relaciona con el resto de variables que tenemos, así que no sería de ayuda que tenga datos no reales.

##### Variables numéricas

Para las variables numéricas, consideramos dos métodos de imputación: la **media** y la **mediana**. La selección de la medida a usar para imputar los datos faltantes se hará según el coeficiente de variación.

```{r}
# Esta función calcula el coeficiente de variación de `x`
# ignorando los NAs
cvs <- apply(df %>% select(edad, balance, campana), 2, cv)
cvs
```

El criterio que usaremos es el siguiente:

- Si $\text{CV} < 30\%$, entonces se imputará la **media**, ya que los datos son homogéneos.
- Si $\text{CV} \geq 30\%$, entonces se imputará la **mediana**, ya que los datos se inclinan más hacia ser heterogéneos.

Realizamos este criterio con el objetivo de imputar la medida que mejor represente a cada variable: sabemos que la media es más representativa cuando la dispersión es baja, mientras que, caso contrario, la mediana es más representativa.

Además, si la variable imputada debe ser discreta, el valor de reemplazo se redondea al entero más cercano.

```{r}
for (colname in names(cvs)) {
  x <- df[[colname]]

  x_mean = mean(x, na.rm = TRUE)
  x_median = median(x, na.rm = TRUE)

  # Si CV < 0.3, usar la media; sino, la mediana
  replace_value <- ifelse(cvs[[colname]] < 0.3, x_mean,  x_median)

  if (is.discrete(x))
    replace_value <- round(replace_value)

  df[[colname]] <- replace_na(x, replace_value)
}
```

#### Eliminación de observaciones

La particularidad de la columna `pdias` de poder incluir valores `-1` (nulos) podría dificultar la decisión sobre qué valor imputar a sus datos faltantes. Sin embargo, en esta base de datos particular, `pdias` sólo tiene un valor faltante, por lo que podemos optar por simplemente eliminar dicha observación completamente.

```{r}
df <- df %>% filter(!is.na(df$pdias))
```

### Comprobaciones finales

#### Búsqueda de datos atípicos

Para las variables numéricas, es prudente comprobar que la data no salga de rangos realistas (no debería haber alguna edad, por ejemplo, de 200 años).

```{r}
summary(df %>% select(edad, balance, campana, pdias))
```

La columna `edad` presenta un rango aceptable: de `r min(df$edad)` a `r max(df$edad)` años.

La columna `balance`, por su máximo, podría levantar sospechas. Sin embargo, un diagrama de caja ayuda a visualizar que la mayoría de datos se encuentran alrededor de la mediana: `r median(df$edad)` euros.

```{r}
boxplot(df$balance, main = "Balance promedio anual")
```

Se aprecia que el valor máximo de `balance` es un valor atípico, y considerando lo alejado que está del resto, consideramos que es completamente posible y no debería ser eliminado.

La columna `campana` también podría levantar sospechas, pero su diagrama de caja nos facilita una conclusión similar a la anterior:

```{r}
boxplot(df$campana, main = "Número de contactos realizados durante la campaña")
```

El máximo de `campana`, aunque es comparablemente alto al resto, es posible en la vida real.

Finalmente, el `pdias` se debe hacer por separado ya que, como muestra su `summary`, está tomando en cuenta a los `-1`s, los cuales, más que un valor numérico real, son un código para un valor "nulo".

Por ello, conviene hacer un `summary` de `pdias` ignorando sus valores `-1`:

```{r}
summary(df$pdias[df$pdias != -1])
```

Ocurre un caso similar a los anteriores.

```{r}
boxplot(df$pdias, main = "Días desde el último contacto al cliente")
```

La mayoría de los datos de `pdias` se encuentran alrededor de la mediana, `r median(df$pdias[df$pdias != -1])`, mientras que los más altos o bien son pocos, o en cualquier caso son posibles en la vida real.

#### Consistencia de las variables categóricas

Finalmente, es preciso comprobar que las variables categóricas tienen valores consistentes. Por ejemplo, la columna `estciv`, ya que contiene al menos los valores `"married"`, `"single"` y `"divorced"`, no debería contener versiones alternativas de estos, como por ejemplo `"Married"` o `"SINGLE"`.

Podemos comprobar los valores presentes en cada una de estas variables con la función `unique`:

```{r}
apply(df %>% select(estciv, educacion, mora, adq_ahorro), 2, unique)
```

De esta manera, podemos comprobar que las variables categóricas tienen valores consistentes.

### Resultado final

Mostramos a continuación un vistazo al resultado de la base de datos tras la limpieza:

```{r}
summary(df)
kable(df[1:12, ])
```

Además, podemos comprobar que está libre de datos faltantes:

```{r}
colSums(is.na(df))
```

## Organización/visualización de datos y análisis descriptivo

En esta sección, presentamos algunas visualizaciones de las variables pertinentes a cada objetivo planteado.

### Vista general

```{r}
# Esta función imprime información relevante sobre una columna
full_summary <- function(x) {
  print(summary(x))

  if (class(x) == "numeric") {
    cat("Rango:", round(ran(x), 2), "\n")
    cat("IQR:", round(IQR(x), 2), "\n")
    cat("SD:", round(sd(x), 2), "\n")
    cat("CV:", round(cv(x), 2), "\n")
    cat("Moda:", round(mfv(x), 2), "\n")
  } else {
    freqs <- table(x)
    rel_freqs <- prop.table(freqs)
    full_table <- rbind(absolute = freqs, relative = round(rel_freqs, 2))

    cat("\n")
    cat("Frecuencias:\n")
    print(full_table)
    cat("\n")
    cat("Moda:", mfv(x), "\n")
  }
}
```

#### Balance

Primero, graficamos un histograma:

```{r}
full_summary(df$balance)
hist(df$balance, main = "Histograma del balance de los encuestados", xlab = "balance")
```

Sin embargo, el histograma no parece ser de mucha utilidad inicialmente. Un diagrama de cajas muestra por qué: los datos atípicos.

```{r}
boxplot(df$balance, main = "Diagrama de caja del balance")
```

Como `balance` tiene una cantidad considerable de datos atípicos, conviene también graficar únicamente los datos dentro del rango intercuartílico para visualizar el "montón" principal de datos.

```{r}
filter_outliers <- function(x, factor = 1.5) {
  iqr = IQR(x)
  lower_bound = quantile(x, 0.25) - factor * iqr
  upper_bound = quantile(x, 0.75) + factor * iqr
  iqr_balances = x[x >= lower_bound & x < upper_bound]
}

hist(
  filter_outliers(df$balance, 0),
  main = "Histograma del balance de los encuestados (rango intercuartílico)",
  xlab = "balance"
)
```

#### Mora

Ahora graficamos `mora`:

```{r}
full_summary(df$mora)

mora_table <- table(df$mora)
bars <- barplot(mora_table, col = rainbow(2), main = "Estado de mora de los encuestados", ylim = c(0, 2400))
text(bars, mora_table + 100, labels = mora_table)

```

De este grafico podemos observar que tener mora no es muy común en la muestra que tenemos (1.47%)

```{r}
moda_mora_adq <- mfv(df$mora[df$adq_ahorro==1])
cat("Moda de los que si adquirieron:",moda_mora_adq,"\n")

moda_mora_noadq <- mfv(df$mora[df$adq_ahorro==0])
cat("Moda de los que no adquirieron:",moda_mora_noadq,"\n")
```

Y en ambos casos, la moda de la mora es que no se cuenta con un estado de mora.

Habiendo expresado de forma visual el balance y la mora, podemos realizar comparaciones con la variable relacionada a la adquisicion de la cuenta de ahorro.

```{r}
boxplot(df$balance~df$adq_ahorro,ylim=c(0,4000),xlab="Adquisición de la cuenta de ahorro (0 = no, 1 = sí)",ylab="Balance", main="Diagrama de caja del balance", col = rainbow(length(unique(df$adq_ahorro))))
```

```{r}
writeLines("Balance del personas que si adquirieron la cuenta de ahorros:")
full_summary(df$balance[df$adq_ahorro==1])
cat("CV:",sd(df$balance[df$adq_ahorro==1])/mean(df$balance[df$adq_ahorro==1]))

writeLines("\n\nBalance del personas que no adquirieron la cuenta de ahorros:")
full_summary(df$balance[df$adq_ahorro==0])
cat("CV:",sd(df$balance[df$adq_ahorro==0])/mean(df$balance[df$adq_ahorro==0]))
```

Aunque Q1 y la mediana (Q2) se mantengan bastante similares, Q3 es visiblemente mayor para las personas que si adquirieron la cuenta de ahorros. Además, la desviacion estandar es considerablemente mayor para los casos donde si adquirieron la cuenta.

Ahora comparando con la mora, realizamos una tabla de doble entrada para comparar las dos variables dicotomicas:

#### Edad

Un histograma puede ofrecer un vistazo a la distribución de los datos:

```{r}
hist(
  df$edad,
  main = "Histograma de la edad de los encuestados",
  xlab = "Edad (años)",
  ylab = "Frecuencia"
)
```

Podemos observar que existe una considerable acumulación de datos alrededor de la marca de 35 años. Un diagrama de caja también nos permite observar una estructura similar:

```{r}
boxplot(df$edad)
```

Al mismo tiempo, podemos notar la presencia de algunos datos atípicos fuera de los bigotes. No obstante los datos no son erróneos: siguen siendo edades aceptables.

También podemos darle un vistazo a las medidas numéricas de `edad`:

```{r}
full_summary(df$edad)
```

Como se puede observar, el rango de `edad` (entre `r min(df$edad)` y `r max(df$edad)` años) es aceptable y realista. Además, la mayoría de los datos se encuentran entre los `r quantile(df$edad, 0.25, type = 3)` y `r quantile(df$edad, 0.75, type = 3)` años (el rango intercuartílico), lo cual tiene sentido realísticamente.

Además, el coeficiente de variación es menor a 30%, por lo que:

1. Los datos tienen dispersión baja.

2. Podemos tomar a la media como la medida representativa del conjunto (aunque igual está cerca a la mediana, en cualquier caso).

Además, aunque no es una medida tan representativa de esta variable, la moda de `r mfv(df$edad)` años que presenta `edad` confirma numéricamente el pico del histograma que vimos anteriormente.

#### Estado civil

Podemos observar las frecuencias relativas de cada estado civil mediante un gráfico circular.

```{r}
estciv_table <- table(df$estciv)
labels <- paste0(round(100 * estciv_table / sum(estciv_table), 2), "%")

colors = rainbow(length(estciv_table))
pie(estciv_table, labels = labels, col = colors, main = "Porcentajes de estado civil en los encuestados")
legend("topleft", legend = c("Divorciado", "Casado", "Soltero"), fill = colors)
```

Esto nos permite ver que la mayoría de encuestados están casados (y la segunda mayoría están solteros), aunque no nos permite concluir mucho más.

Este gráfico se puede ver de forma numérica si construimos la tabla de frecuencias (absoluta y relativa) de `estciv`:

```{r}
full_summary(df$estciv)
```

#### Educación

#### Campaña

```{r}
hist(df$campana)
```

Al igual que en `balance`, un diagrama de caja muestra por qué este histograma no es tan informativo:

```{r}
boxplot(df$campana)
```

Nuevamente parece conveniente graficar un subconjunto relevante de los datos. En este caso, basta con dejar afuera a los datos atípicos.

```{r}
# Usaremos esta función para filtrar datos fuera de un cierto rango
filter_outliers <- function(x, factor = 1.5) {
  iqr = IQR(x)
  lower_bound = quantile(x, 0.25) - factor * iqr
  upper_bound = quantile(x, 0.75) + factor * iqr
  iqr_balances = x[x >= lower_bound & x < upper_bound]
}
```

Sin embargo, resulta que este subconjunto que vamos a graficar sólo tiene `r length(unique(filter_outliers(df$campana)))` valores únicos, así que conviene un gráfico de barras.

```{r}
campana_2_table <- table(filter_outliers(df$campana))

barplot(
  campana_2_table,
  main = "Gráfico de barras de campaña (sin atípicos)",
  xlab = "Número de contactos (campaña)",
  ylab = "Frecuencia"
)
```

Con respecto a las medidas, `campana` produce lo siguiente:

```{r}
full_summary(df$campana)
```

Podemos notar que el rango (`r ran(df$campana)` contactos) es muy elevado en comparación al rango intercuartílico (`r IQR(df$campana)` contactos). Esto confirma los gráficos anteriores: la gran mayoría de datos de `campana` yacen alrededor de `r quantile(df$campana, 0.25, type = 3)` y `r quantile(df$campana, 0.75, type = 3)` días. Sólo hay algunos datos atípicos, los cuales escapan drásticamente ese rango.

Además, es debido a estos datos atípicos tan altos que el coeficiente de variación de `campana` resulta mayor incluso al $100\%$.

#### pdias

### Vista por objetivo

#### Objetivo 1

> Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.

```{r}
tabla_moravsadq <- table(df$adq_ahorro,df$mora)
tabla_moravsadq
```

Y ahora la utilizamos para generar un diagrama de mosaico:

```{r}
mosaicplot(tabla_moravsadq,main="Diagrama de mosaico",ylab = "Mora",xlab = "Adquisicion de la cuenta de ahorro (0 = no, 1 = si)")
```

El grafico resulta aplastado ya que la cantidad de obseraciones donde si se tiene mora es muy pequeña, seria apropiado entonces tener un enfoque en los porcentajes de la tabla de doble entrada:

```{r}

tabla_doble_entrada <- prop.table(table(df$adq_ahorro,df$mora),margin=2)
round(tabla_doble_entrada*100,2)
```

```{r}
tabladf <- as.data.frame.matrix(tabla_doble_entrada)

data_long <- pivot_longer(tabladf, cols = c(si,no), names_to = "Mora", values_to = "Porcentaje")
data_long$Group <- rep(c("0", "1"), each = 2)


ggplot(data_long, aes(x = Mora, y = Porcentaje, fill = Group)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.2f%%", Porcentaje * 100)), 
            position = position_stack(vjust = 0.5), size = 4) +
  scale_fill_manual(values = c("skyblue", "lightcoral")) +
  labs(x = "Mora", y = "Porcentaje", fill = "Adquisición (0 = no, 1 = sí)") +
  scale_y_continuous(labels = scales::percent)
```

Ahora podiendo apreciar un gráfico más proporcional, podemos observar que hay una proporción *ligeramente* mayor de personas que aceptan la cuenta de ahorros cuando si cuentan con mora.

#### Objetivo 2

> Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.

Un diagrama de caja nos puede permitir comparar posibles diferencias entre las edades de quienes adquirieron una cuenta de ahorro de quienes no.

```{r}
boxplot(
  df$edad ~ df$adq_ahorro,
  main = "Diagrama de caja de la edad de los encuestados",
  xlab = "Adquisición de la cuenta de ahorro (0 = no, 1 = sí)", ylab = "Edad (años)",
  col = rainbow(length(unique(df$adq_ahorro)))
)
```

Una observación interesante de este gráfico es que muestra cómo la mayoría de encuestados con edades atípicas (es decir, las edades por encima de alrededor de 70) adquirieron la cuenta de ahorro. Aunque sólo se trate de algunos datos particulares, esta observación puede ser relevante para un análisis más adelante.

Nuevamente, resulta útil realizar una comparación entre quienes adquirieron la cuenta de ahorro y quienes no lo hicieron. Para ello, nos conviene usar un diagrama de mosaico.

```{r}
data <- table(df$adq_ahorro, df$estciv)
mosaicplot(data, main = "Diagrama de mosaico", color = TRUE)
```

Sin embargo, parece que, a primera vista, no hay una diferencia significativa entre el nivel educativo de los que adquirieron la cuenta de ahorro y quienes no. Pese a ello, podemos notar que, entre las personas que sí adquirieron la cuenta, hay *ligeramente* menos individuos casados (divorciados, en su lugar).

Otro vistazo interesante a estas variables es analizar diagramas de caja de las edades para cada estado civil.

```{r}
boxplot(
  df$edad ~ df$estciv,
  main = "Diagrama de caja de edades por estado civil",
  col = rainbow(length(unique(df$estciv))),
  xlab = "Estado civil",
  ylab = "Edad (años)"
)
```

Podemos observar de forma notoria que las personas solteras tienden a tener edades menores que las personas casadas o divorciadas, lo cual tiene sentido si consideramos que, intuitivamente, una persona mayor tiene más probabilidad de estar casada que una persona más joven.

Además, se puede observar que la caja correspondiente a los individuos divorciados está muy ligeramente movida un poco más arriba que la de los individuos casados. Es una diferencia extremadamente pequeña, pero igualmente tiene sentido.

#### Objetivo 3

> Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.

#### Objetivo 4

> Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.

```{r}
ggplot(df, aes(x = campana, fill = factor(adq_ahorro))) +
  geom_histogram(bins = 30, position = "dodge", alpha = 0.7) +
  facet_wrap(~adq_ahorro, scales = "free_y") +
  labs(
    title = "Histogramas de campana por adquisición de cuenta de ahorro",
    x = "Número de contactos (campaña)",
    y = "Frecuencia",
    fill = "Adquirió cuenta (1 = Sí, 0 = No)"
  ) +
  theme_minimal()
```

```{r}
resumen_campana <- df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(campana),
    mediana = median(campana),
    moda = mfv(campana),
    cv = cv(campana),
    max = max(campana),
    min = min(campana),
    rango = ran(campana),
    sd = sd(campana),
  )

kable(resumen_campana)
```

A partir de estas medidas podemos realizar las siguientes observaciones:

1. Media y mediana:
   - La media y la mediana son muy similares entre los dos grupos:
     - No adquirieron: Media = 2.796, Mediana = 2.
     - Adquirieron: Media = 2.840, Mediana = 2.
   - Esto indica que, en promedio, el número de contactos realizados es casi igual para ambos grupos.
   - La mediana igual en ambos casos (2) sugiere que la distribución está centrada cerca de este valor.
2. Desviación estándar:
   - Los clientes que adquirieron la cuenta tienen una desviación estándar más alta (3.304 frente a 2.649), lo que indica mayor dispersión en el número de contactos realizados.
   - Es decir, el número de contactos es más variable para los clientes que adquirieron la cuenta.
3. Coeficiente de variación:
   - Los clientes que adquirieron la cuenta tienen un coeficiente de variación mayor (1.163 frente a 0.947), lo que confirma que existe mayor variabilidad relativa en comparación con los que no adquirieron la cuenta.
4. Máximo y rango:
   - El máximo número de contactos es significativamente mayor para los clientes que adquirieron la cuenta (50 frente a 21), lo que puede indicar que, en algunos casos, un mayor número de intentos está relacionado con la decisión de adquirir la cuenta.
   - El rango también es más amplio para quienes adquirieron la cuenta (49 frente a 20), lo que reafirma que existe mayor dispersión.
5. Moda:
   - La moda en ambos grupos es 1, lo que indica que el número más frecuente de contactos realizados fue uno solo. Esto puede estar relacionado con un esfuerzo inicial que no necesariamente garantiza el éxito.

Otras conclusiones que podemos obtener de este análisis son:

1. El número de contactos realizados (campana) es similar en promedio para ambos grupos, pero quienes adquirieron la cuenta muestran mayor dispersión, rango y un valor máximo más alto.
2. Esto sugiere que, aunque el número promedio de contactos no varía mucho, en algunos casos, un mayor número de contactos parece estar relacionado con la adquisición de la cuenta.

#### Objetivo 5

> Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.
