---
title: Estadística y probabilidades - PG1
author:
  - José Daniel Grayson Tejada (líder)
  - Fali Ferdinand Araoz Arana
  - Leisy Valeska Bendezu Choque
  - Daniela Landavery Vergaray
  - Vincenzo Francisco Magnani Castro
lang: es
editor: visual
toc: true
format:
  html:
    toc: true
    toc-depth: 4
embed-resources: true
---

## Objetivos

El objetivo principal de este proyecto es conocer los factores que influyen en la aceptación de una cuenta de ahorro vía telefónica para los clientes de una entidad bancaria a través de la identificación de patrones usando el análisis estadístico.

Dentro de este marco general, nuestro grupo considera los siguientes objetivos específicos:

1. Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.
2. Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.
3. Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.
4. Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.
5. Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.

Cabe destacar que en todos estos objetivos se hace presente la variable `adq_ahorro` como la variable dependiente que queremos analizar.

## Limpieza de datos

```{r}
cv <- function(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
is.discrete <- function(x) all(x == as.integer(x), na.rm = TRUE)
ran <- function(x) max(x) - min(x)
```

Primero, cargamos las librerías que usaremos para limpiar los datos.

```{r}
#| output: false

if (!require("tidyverse")) install.packages("tidyverse")
if (!require("modeest")) install.packages("modeest")
if (!require("knitr")) install.packages("knitr")
if (!require("ggplot2")) install.packages("ggplot2")

library("tidyverse") # `dplyr` viene con tidyverse
library("modeest")
library("knitr")
```

Ahora, leemos el CSV con los datos y mostramos un breve vistazo con las primeras 12 observaciones:

```{r}
df <- read_csv("AdquisicionAhorro.csv")
kable(df[1:12, ])
```

En total, esta tabla tiene `r ncol(df)` columnas (es decir, variables) y `r nrow(df)` filas (es decir, observaciones).

Con análisis manual, podemos clasificar a las variables que esta tabla contiene:

| Variable     | Tipo         | Sub-tipo |
| ------------ | ------------ | -------- |
| `coddoc`     | cualitativa  | nominal  |
| `edad`       | cuantitativa | discreta |
| `estciv`     | cualitativa  | nominal  |
| `educacion`  | cualitativa  | nominal  |
| `mora`       | cualitativa  | nominal  |
| `balance`    | cuantitativa | continua |
| `vivienda`   | cualitativa  | nominal  |
| `prestamo`   | cualitativa  | nominal  |
| `dia`        | cuantitativa | discreta |
| `duracion`   | cuantitativa | discreta |
| `campana`    | cuantitativa | discreta |
| `pdias`      | cuantitativa | discreta |
| `previo`     | cuantitativa | discreta |
| `adq_ahorro` | cualitativa  | nominal  |

:::{.callout-important}
Nótese que, a lo largo de este documento, clasificamos a `adq_ahorro` como categórico porque es esencialmente un sí/no codificado como 1/0.
:::

### Transformación de datos

Como paso preliminar, renombraremos la última columna de `df` para tener consistencia entre los nombres de todas las columnas:

```{r}
if ("Adq_Ahorro" %in% colnames(df))
  df <- df %>% rename(adq_ahorro = Adq_Ahorro)
```

#### Eliminación de variables innecesarias

Acorde con los objetivos establecidos, conservaremos únicamente las siguientes variables:

- `edad`
- `estciv`
- `educacion`
- `mora`
- `balance`
- `campana`
- `pdias`
- `adq_ahorro`

```{r}
df <- df %>% select(edad, estciv, educacion, mora, balance, campana, pdias, adq_ahorro)
```

#### Arreglo del tipo de `balance`

Podemos observar que la columna `balance` no es de tipo numérico (como debería de ser), sino que es de tipo carácter. Esto significa que existe algún dato en `balance` que no es un valor numérico válido.

Ante ello, podemos usar la función `as.numeric` para convertir a la fuerza los datos de `balance` a números. Los que no se puedan convertir correctamente se convertirán en `NA`, con lo cual se lidiará al tratar con los datos faltantes.

```{r}
df$balance <- as.numeric(df$balance)
```

En efecto, podemos comprobar que la columna `balance` ahora es de tipo numérico:

```{r}
typeof(df$balance)
```

### Tratamiento de datos faltantes

Un chequeo rápido hace notar que la mayoría de variables contienen algunos datos faltantes:

```{r}
colSums(is.na(df))
```

En total, esto constituye `r sum(is.na(df))` datos faltantes, lo cual es aproximadamente un `r round(100 * sum(is.na(df)) / (ncol(df) * nrow(df)))`% del total de `r ncol(df) * nrow(df)` datos presentes en la tabla.

En términos de observaciones en general, los datos contienen `r sum(!complete.cases(df))` observaciones con algún dato faltante, lo cual es un `r round(100 * sum(!complete.cases(df)) / nrow(df))`% del total.

#### Imputación de datos

##### Variables categóricas

Para las variables categóricas, imputaremos como reemplazo a los datos faltantes la **moda** de los datos existentes.

```{r}
# Esta función calcula la moda de una lista de datos `x`
# y la imputa en sus valores faltantes.
input_mode <- function(x) replace_na(x, mfv(x))

df$estciv <- replace_na(df$estciv, mfv(df$estciv))
df$educacion <- replace(df$educacion, is.na(df$educacion) | df$educacion == "desconocido", mfv(df$educacion))
df$mora <- replace_na(df$mora, mfv(df$mora))
```

::: {.callout-note}
Nótese que en la columna `educacion` imputamos también sobre las celdas que contienen `"desconocido"`, ya que, para propósitos de este proyecto, representan exactamente lo mismo que un `NA`: el dato no se conoce.
:::

Esta imputación no se realiza en `adq_ahorro` por dos razones:

1. `adq_ahorro` en realidad no tiene datos faltantes.
2. `adq_ahorro` es la variable dependiente del análisis. Queremos encontrar cómo se relaciona con el resto de variables que tenemos, así que no sería de ayuda que tenga datos no reales.

##### Variables numéricas

Para las variables numéricas, consideramos dos métodos de imputación: la **media** y la **mediana**. La selección de la medida a usar para imputar los datos faltantes se hará según el coeficiente de variación.

```{r}
# Esta función calcula el coeficiente de variación de `x`
# ignorando los NAs
cvs <- apply(df %>% select(edad, balance, campana), 2, cv)
cvs
```

El criterio que usaremos es el siguiente:

- Si $\text{CV} < 30\%$, entonces se imputará la **media**, ya que los datos son homogéneos.
- Si $\text{CV} \geq 30\%$, entonces se imputará la **mediana**, ya que los datos se inclinan más hacia ser heterogéneos.

Realizamos este criterio con el objetivo de imputar la medida que mejor represente a cada variable: sabemos que la media es más representativa cuando la dispersión es baja, mientras que, caso contrario, la mediana es más representativa.

Además, si la variable imputada debe ser discreta, el valor de reemplazo se redondea al entero más cercano.

```{r}
for (colname in names(cvs)) {
  x <- df[[colname]]

  x_mean = mean(x, na.rm = TRUE)
  x_median = median(x, na.rm = TRUE)

  # Si CV < 0.3, usar la media; sino, la mediana
  replace_value <- ifelse(cvs[[colname]] < 0.3, x_mean,  x_median)

  if (is.discrete(x))
    replace_value <- round(replace_value)

  df[[colname]] <- replace_na(x, replace_value)
}
```

#### Eliminación de observaciones

La particularidad de la columna `pdias` de poder incluir valores `-1` (nulos) podría dificultar la decisión sobre qué valor imputar a sus datos faltantes. Sin embargo, en esta base de datos particular, `pdias` sólo tiene un valor faltante, por lo que podemos optar por simplemente eliminar dicha observación completamente.

```{r}
df <- df %>% filter(!is.na(df$pdias))
```

### Comprobaciones finales

#### Búsqueda de datos atípicos

Para las variables numéricas, es prudente comprobar que la data no salga de rangos realistas (no debería haber alguna edad, por ejemplo, de 200 años).

```{r}
summary(df %>% select(edad, balance, campana, pdias))
```

La columna `edad` presenta un rango aceptable: de `r min(df$edad)` a `r max(df$edad)` años.

La columna `balance`, por su máximo, podría levantar sospechas. Sin embargo, un diagrama de caja ayuda a visualizar que la mayoría de datos se encuentran alrededor de la mediana: `r median(df$edad)` euros.

```{r}
boxplot(df$balance, main = "Balance promedio anual")
```

Se aprecia que el valor máximo de `balance` es un valor atípico, y considerando lo alejado que está del resto, consideramos que es completamente posible y no debería ser eliminado.

La columna `campana` también podría levantar sospechas, pero su diagrama de caja nos facilita una conclusión similar a la anterior:

```{r}
boxplot(df$campana, main = "Número de contactos realizados durante la campaña")
```

El máximo de `campana`, aunque es comparablemente alto al resto, es posible en la vida real.

Finalmente, el `pdias` se debe hacer por separado ya que, como muestra su `summary`, está tomando en cuenta a los `-1`s, los cuales, más que un valor numérico real, son un código para un valor "nulo".

Por ello, conviene hacer un `summary` de `pdias` ignorando sus valores `-1`:

```{r}
summary(df$pdias[df$pdias != -1])
```

Ocurre un caso similar a los anteriores.

```{r}
boxplot(df$pdias, main = "Días desde el último contacto al cliente")
```

La mayoría de los datos de `pdias` se encuentran alrededor de la mediana, `r median(df$pdias[df$pdias != -1])`, mientras que los más altos o bien son pocos, o en cualquier caso son posibles en la vida real.

#### Consistencia de las variables categóricas

Finalmente, es preciso comprobar que las variables categóricas tienen valores consistentes. Por ejemplo, la columna `estciv`, ya que contiene al menos los valores `"married"`, `"single"` y `"divorced"`, no debería contener versiones alternativas de estos, como por ejemplo `"Married"` o `"SINGLE"`.

Podemos comprobar los valores presentes en cada una de estas variables con la función `unique`:

```{r}
apply(df %>% select(estciv, educacion, mora, adq_ahorro), 2, unique)
```

De esta manera, podemos comprobar que las variables categóricas tienen valores consistentes.

### Resultado final

Mostramos a continuación un vistazo al resultado de la base de datos tras la limpieza:

```{r}
summary(df)
kable(df[1:12, ])
```

Además, podemos comprobar que está libre de datos faltantes:

```{r}
colSums(is.na(df))
```

## Organización/visualización de datos y análisis descriptivo

En esta sección, presentamos algunas visualizaciones de las variables pertinentes a cada objetivo planteado.

```{r}
# Esta función imprime información relevante sobre una columna
full_summary <- function(x) {
  print(summary(x))

  if (class(x) == "numeric") {
    cat("Rango:", round(ran(x), 2), "\n")
    cat("IQR:", round(IQR(x), 2), "\n")
    cat("SD:", round(sd(x), 2), "\n")
    cat("CV:", round(cv(x), 2), "\n")
    cat("Moda:", round(mfv(x), 2), "\n")
  } else {
    freqs <- table(x)
    rel_freqs <- prop.table(freqs)
    full_table <- rbind(absolute = freqs, relative = round(rel_freqs, 2))

    cat("\n")
    cat("Frecuencias:\n")
    print(full_table)
    cat("\n")
    cat("Moda:", mfv(x), "\n")
  }
}

filter_outliers <- function(x, factor = 1.5) {
  iqr = IQR(x)
  lower_bound = quantile(x, 0.25) - factor * iqr
  upper_bound = quantile(x, 0.75) + factor * iqr
  iqr_balances = x[x >= lower_bound & x < upper_bound]
}
```

### Objetivo 1 (balance, mora)

> Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.

Podemos realizar comparaciones con la variable relacionada a la adquisición de la cuenta de ahorro.

**Figura 1**

```{r}
boxplot(
  df$balance ~ df$adq_ahorro,
  ylim=c(0,4000),
  main="Balance por adquisición de ahorro",
  xlab="Adquisición de la cuenta de ahorro",
  ylab="Balance (euros)",
  names = c("no", "sí"),
  col = rainbow(length(unique(df$adq_ahorro)))
)
```

*Nota: Nótese cómo los balances de quienes sí adquirieron la cuenta de ahorro abarcan cantidades mayores que quienes no adquirieron la cuenta.*

```{r}
df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(balance),
    q1 = quantile(balance, 0.25, type = 3),
    mediana = median(balance),
    q3 = quantile(balance, 0.75, type = 3),
    moda = mfv(balance),
    cv = cv(balance),
    max = max(balance),
    min = min(balance),
    rango = ran(balance),
    sd = sd(balance),
  )
```

Aunque $Q_1$ y la mediana se mantengan bastante similares, $Q_3$ es visiblemente mayor para las personas que sí adquirieron la cuenta de ahorros. Además, la desviación estándar es considerablemente mayor para los casos donde sí adquirieron la cuenta.

Con respecto a la mora, es importante notar primero que, de hecho, sólo una pequeña minoría de los encuestados tiene mora:

```{r}
full_summary(df$mora)
```

Más precisamente, sólo el `r 100 * round(sum(df$mora == "si") / length(df$mora), 2)`% de los encuestados tienen mora pendiente. Sin embargo, esta baja frecuencia no necesariamente significa que la variable no tendrá aporte en el análisis.

Ahora comparando con la mora, realizamos una tabla de doble entrada para comparar las dos variables dicotómicas:

```{r}
tabla_doble_entrada <- prop.table(table(df$adq_ahorro, df$mora), margin=2)
round(100 * tabla_doble_entrada, 2)
```

**Figura 2**

```{r}
tabladf <- as.data.frame.matrix(tabla_doble_entrada)

data_long <- pivot_longer(tabladf, cols = c(si,no), names_to = "Mora", values_to = "Porcentaje")
data_long$Group <- rep(c("0", "1"), each = 2)


ggplot(data_long, aes(x = Mora, y = Porcentaje, fill = Group)) +
  ggtitle("Porcentaje de adquisición por mora") +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.2f%%", Porcentaje * 100)), 
            position = position_stack(vjust = 0.5), size = 4) +
  scale_fill_manual(values = c("skyblue", "lightcoral")) +
  labs(x = "Mora", y = "Porcentaje", fill = "Adquisición (0 = no, 1 = sí)") +
  scale_y_continuous(labels = scales::percent)
```

*Nota: La muestra de personas que poseen mora sólo contiene 33 observaciones.*

Ahora pidiendo apreciar un gráfico más proporcional, podemos observar que hay una proporción *ligeramente* mayor de personas que aceptan la cuenta de ahorros cuando si cuentan con mora.

### Objetivo 2 (edad, estado civil)

> Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.

Un diagrama de caja nos puede permitir comparar posibles diferencias entre las edades de quienes adquirieron una cuenta de ahorro de quienes no.

**Figura 3**

```{r}
boxplot(
  df$edad ~ df$adq_ahorro,
  main = "Edad por adquisición de cuenta de ahorro",
  xlab = "Adquisición de la cuenta de ahorro", ylab = "Edad (años)",
  names = c("no", "sí"),
  col = rainbow(length(unique(df$adq_ahorro)))
)
```

*Nota: Este gráfico muestra una propiedad de los datos atípicos en `edad`.*

Una observación interesante de este gráfico es que muestra cómo la mayoría de encuestados con edades atípicas (es decir, las edades por encima de alrededor de 70) adquirieron la cuenta de ahorro.

```{r}
df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(edad),
    mediana = median(edad),
    moda = mfv(edad),
    cv = cv(edad),
    max = max(edad),
    min = min(edad),
    rango = ran(edad),
    sd = sd(edad),
  )
```

Nuevamente, resulta útil realizar una comparación entre quienes adquirieron la cuenta de ahorro y quienes no lo hicieron. Para ello, nos conviene usar un diagrama de mosaico.

**Figura 4**

```{r}
mosaicplot(
  table(df$adq_ahorro, df$estciv),
  main = "Estado civil por adquisición de cuenta (0 = no, 1 = sí)",
  xlab = "Adquisición de cuenta",
  ylab = "Estado civil",
  color = TRUE
)
```

*Nota: Este diagrama muestra una ligera relevancia del estado civil "casado".*

Sin embargo, parece que, a primera vista, no hay una diferencia significativa entre el estado civil de los que adquirieron la cuenta de ahorro y quienes no. Pese a ello, podemos notar que, entre las personas que sí adquirieron la cuenta, hay *ligeramente* menos individuos casados (divorciados, en su lugar) en comparación a quienes no la adquirieron.

Otro vistazo interesante a estas variables es analizar diagramas de caja de las edades para cada estado civil.

**Figura 5**

```{r}
boxplot(
  df$edad ~ df$estciv,
  main = "Edad por estado civil",
  xlab = "Estado civil",
  ylab = "Edad (años)",
  col = rainbow(length(unique(df$estciv)))
)
```

*Nota: Este gráfico muestra una importante correlación entre el estado civil y la edad.*

Podemos observar de forma notoria que las personas solteras tienden a tener edades menores que las personas casadas o divorciadas, lo cual tiene sentido si consideramos que, intuitivamente, una persona mayor tiene más probabilidad de estar casada que una persona más joven.

Además, se puede observar que la caja correspondiente a los individuos divorciados está muy ligeramente movida un poco más arriba que la de los individuos casados. Es una diferencia extremadamente pequeña, pero igualmente tiene sentido.

### Objetivo 3 (educación)

> Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.

Podemos usar un gráfico de mosaico para visualizar la relación entre `educacion` y `adq_ahorro`:

**Figura 6**

```{r}
# Crear tabla de datos
data <- table(df$educacion, df$adq_ahorro)

# Gráfico de mosaico
mosaicplot(data,
  main = "Adquisición de cuenta por nivel educativo",
  xlab = "Nivel educativo",
  ylab = "Adquisición de cuenta (0 = no, 1 = sí)",
  color = c("tomato", "steelblue")
)
```

*Nota: Este diagrama se ve afectado por el hecho de que la mayoría de encuestados tengan nivel educativo de secundaria, ya que observa a cada nivel educativo por separado independientemente del tamaño de su muestra particular.*

Podemos observar que, a grandes rasgos, el nivel educativo de secundaria es el más propenso a adquirir cuentas de ahorro, aunque por un margen relativamente pequeño. En ese mismo sentido, es el nivel educativo de primaria el que menos adquisiciones de cuentas de ahorro tiene.

Sin embargo, es relevante notar que el nivel de educación terciario no sea el predominante en la adquisición de la cuenta, ya que, intuitivamente, una persona con educación superior debería estar informada de mejores prácticas de finanzas. Sin embargo, esto se podría explicar si consideráramos que estas personas podrían haber rechazado la cuenta por ya contar con una en otro banco.

### Objetivo 4 (campaña)

> Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.

**Figura 7**

```{r}
ggplot(df, aes(x = factor(adq_ahorro), y = campana, fill = factor(adq_ahorro))) +
  geom_boxplot(alpha = 0.9) +
  labs(
    title = "Número de contactos previos por adquisición de cuenta",
    x = "Adquisición de cuenta (1 = Sí, 0 = No)",
    y = "Número de contactos previos (campana)",
    fill = "Adquirió cuenta"
  ) +
  theme_light()
```

*Nota: Las cajas en este gráfico están aplanadas, pero los datos atípicos muestran un patrón relevante.*

```{r}
resumen_campana <- df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(campana),
    mediana = median(campana),
    moda = mfv(campana),
    cv = cv(campana),
    max = max(campana),
    min = min(campana),
    rango = ran(campana),
    sd = sd(campana),
  )

kable(resumen_campana)
```

Podemos observar que la mayoría de medidas en ambos grupos son similares (en particular, la media, mediana y la moda). Sin embargo, los sujetos que sí adquirieron la cuenta de ahorro presentan varios datos atípicos más que quienes no la adquirieron, lo que causa una mayor desviación estándar y coeficiente de variación.

También podemos observar que el número de contactos realizados es similar en promedio para ambos grupos, pero quienes adquirieron la cuenta muestran mayor dispersión, rango y un valor máximo más alto. Esto sugiere que, aunque el número promedio de contactos no varía mucho, en algunos casos, un mayor número de contactos parece estar relacionado con la adquisición de la cuenta.

Otra observación interesante surge con la gráfica general de `campana` (obviando los datos atípicos para enfocarnos en el montón):

**Figura 8**

```{r}
campana_table <- table(filter_outliers(df$campana))

barplot(
  campana_table,
  main = "Contactos previos en la campaña (sin atípicos)",
  xlab = "Número de contactos (campana)",
  ylab = "Frecuencia"
)
```

*Nota: Este gráfico muestra que, además de los datos atípicos, `campana` tiene pocos valores únicos.*

Principalmente, podemos notar que la mayoría de encuestados aceptaron o rechazaron la cuenta de ahorro al primer contacto (ya que la moda de esta variable es `r mfv(df$campana)`). Esto, como se profundizará en el siguiente objetivo, puede ser un indicativo de la importancia que debe tener la primera impresión del banco con los clientes.

### Objetivo 5 (pdias)

> Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.

En primer lugar, podemos observar cuántos valores nulos (`-1`) tiene `pdias`:

```{r}
sum(df$pdias == -1)
```

Esta es una cantidad considerablemente grande (correspondiente al `r round(100 * sum(df$pdias == -1) / length(df$pdias), 2)`% de las observaciones). Quiere decir que el `r round(100 * sum(df$pdias == -1) / length(df$pdias), 2)`% de los encuestados no han sido contactados en alguna campaña.

Por esta presencia de `-1`s, analizaremos esta variable en dos partes.

**Figura 9**

```{r}
df_aux <- df[df$pdias != -1, ]
##convertir esto a un histograma doble
boxplot(
        df_aux$pdias ~ df_aux$adq_ahorro,
        names = c("No", "Si"),
        col = c("blue", "green"), 
        main = "Días desde último contacto por adquisición de cuenta", 
        ylab = "Días desde el último contacto (pdias)", 
        xlab = "Adquisición de la cuenta")
```

*Nota: Esta figura no incluye a los clientes que no habían sido contactados previamente.*

```{r}
df %>% 
  filter(pdias != -1) %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(pdias),
    q1 = quantile(pdias, 0.25, type = 3),
    mediana = median(pdias),
    q3 = quantile(pdias, 0.75, type = 3),
    cv = cv(pdias),
    max = max(pdias),
    min = min(pdias),
    rango = ran(pdias),
    sd = sd(pdias),
  )
```

Con las gráficas y las medidas que vemos aquí, podemos notar que, en general, las personas que adquieren la cuenta de ahorro tienden a hacerlo en un número ligeramente menor de días tras el último contacto que las personas que no la adquieren. La diferencia no es demasiado significativa, pero está presente.

Además, los datos atípicos presentes en las personas que sí adquirieron (los cuales a primera vista parecen contradecir la observación anterior) se pueden explicar como un caso especial: pueden haber sido personas que simplemente no adquirieron la cuenta debido a una campaña particular, sino que mucho tiempo más adelante la pudieron haber adquirido por otras razones.

Por otro lado, podemos analizar los porcentajes de adquisición entre los `r sum(df$pdias == 1)` encuestados que nunca fueron contactados:

**Figura 10**

```{r}
df_aux_2 <- df[df$pdias == -1, ]
pdias_table <- table(df_aux_2$adq_ahorro)

colors <- rainbow(2)
pdias_table <- table(df$pdias != -1)
labels <- paste0(round(100 * pdias_table / sum(pdias_table), 2), "%")

pie(
  pdias_table,
  main = "Adquisición de cuenta (clientes no contactados previamente)",
  labels = labels,
  col = colors
)
legend("topleft", legend = c("Sí adquirió", "No adquirió"), fill = colors)
```

*Nota: Este gráfico incluye exclusivamente a los clientes con valor `-1` en `pdias`.*

Es notorio que, como muestra este gráfico, la mayoría de los clientes que no fueron contactados previamente sí adquirieron la cuenta de ahorro. Considerando que, de hecho, los clientes no contactados previamente ya son la mayor parte de la muestra, sería apropiado concluir que se le debe dar una gran importancia a la primera impresión que el banco le da al cliente. El gráfico de cajas anterior complementa esta idea: los datos de los clientes que sí habían sido contactados previamente, más bien, se dispersan.
