---
title: Estadística y probabilidades - PG1
author:
  - José Daniel Grayson Tejada (líder)
  - Fali Ferdinand Araoz Arana
  - Leisy Valeska Bendezu Choque
  - Daniela Landavery Vergaray
  - Vincenzo Francisco Magnani Castro
lang: es
editor: visual
toc: true
format:
  html:
    toc: true
    toc-depth: 4
embed-resources: true
---

## Objetivos

El objetivo principal de este proyecto es conocer los factores que influyen en la aceptación de una cuenta de ahorro vía telefónica para los clientes de una entidad bancaria a través de la identificación de patrones usando el análisis estadístico.

Dentro de este marco general, nuestro grupo considera los siguientes objetivos específicos:

1. Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.
2. Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.
3. Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.
4. Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.
5. Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.

Cabe destacar que en todos estos objetivos se hace presente la variable `adq_ahorro` como la variable dependiente que queremos analizar.

## Limpieza de datos

```{r}
cv <- function(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
is.discrete <- function(x) all(x == as.integer(x), na.rm = TRUE)
ran <- function(x) max(x) - min(x)
```

Primero, cargamos las librerías que usaremos para limpiar los datos.

```{r}
#| output: false

if (!require("tidyverse")) install.packages("tidyverse")
if (!require("modeest")) install.packages("modeest")
if (!require("knitr")) install.packages("knitr")
if (!require("ggplot2")) install.packages("ggplot2")

library("tidyverse") # `dplyr` viene con tidyverse
library("modeest")
library("knitr")
```

Ahora, leemos el CSV con los datos y mostramos un breve vistazo con las primeras 12 observaciones:

```{r}
df <- read_csv("AdquisicionAhorro.csv")
kable(df[1:12, ])
```

En total, esta tabla tiene `r ncol(df)` columnas (es decir, variables) y `r nrow(df)` filas (es decir, observaciones).

Con análisis manual, podemos clasificar a las variables que esta tabla contiene:

| Variable     | Tipo         | Sub-tipo |
| ------------ | ------------ | -------- |
| `coddoc`     | cualitativa  | nominal  |
| `edad`       | cuantitativa | discreta |
| `estciv`     | cualitativa  | nominal  |
| `educacion`  | cualitativa  | nominal  |
| `mora`       | cualitativa  | nominal  |
| `balance`    | cuantitativa | continua |
| `vivienda`   | cualitativa  | nominal  |
| `prestamo`   | cualitativa  | nominal  |
| `dia`        | cuantitativa | discreta |
| `duracion`   | cuantitativa | discreta |
| `campana`    | cuantitativa | discreta |
| `pdias`      | cuantitativa | discreta |
| `previo`     | cuantitativa | discreta |
| `adq_ahorro` | cualitativa  | nominal  |

:::{.callout-important}
Nótese que, a lo largo de este documento, clasificamos a `adq_ahorro` como categórico porque es esencialmente un sí/no codificado como 1/0.
:::

### Transformación de datos

Como paso preliminar, renombraremos la última columna de `df` para tener consistencia entre los nombres de todas las columnas:

```{r}
if ("Adq_Ahorro" %in% colnames(df))
  df <- df %>% rename(adq_ahorro = Adq_Ahorro)
```

#### Eliminación de variables innecesarias

Acorde con los objetivos establecidos, conservaremos únicamente las siguientes variables:

- `edad`
- `estciv`
- `educacion`
- `mora`
- `balance`
- `campana`
- `pdias`
- `adq_ahorro`

```{r}
df <- df %>% select(edad, estciv, educacion, mora, balance, campana, pdias, adq_ahorro)
```

#### Arreglo del tipo de `balance`

Podemos observar que la columna `balance` no es de tipo numérico (como debería de ser), sino que es de tipo carácter. Esto significa que existe algún dato en `balance` que no es un valor numérico válido.

Ante ello, podemos usar la función `as.numeric` para convertir a la fuerza los datos de `balance` a números. Los que no se puedan convertir correctamente se convertirán en `NA`, con lo cual se lidiará al tratar con los datos faltantes.

```{r}
df$balance <- as.numeric(df$balance)
```

En efecto, podemos comprobar que la columna `balance` ahora es de tipo numérico:

```{r}
typeof(df$balance)
```

### Tratamiento de datos faltantes

Un chequeo rápido hace notar que la mayoría de variables contienen algunos datos faltantes:

```{r}
colSums(is.na(df))
```

En total, esto constituye `r sum(is.na(df))` datos faltantes, lo cual es aproximadamente un `r round(100 * sum(is.na(df)) / (ncol(df) * nrow(df)))`% del total de `r ncol(df) * nrow(df)` datos presentes en la tabla.

En términos de observaciones en general, los datos contienen `r sum(!complete.cases(df))` observaciones con algún dato faltante, lo cual es un `r round(100 * sum(!complete.cases(df)) / nrow(df))`% del total.

#### Imputación de datos

##### Variables categóricas

Para las variables categóricas, imputaremos como reemplazo a los datos faltantes la **moda** de los datos existentes.

```{r}
# Esta función calcula la moda de una lista de datos `x`
# y la imputa en sus valores faltantes.
input_mode <- function(x) replace_na(x, mfv(x))

df$estciv <- replace_na(df$estciv, mfv(df$estciv))
df$educacion <- replace(df$educacion, is.na(df$educacion) | df$educacion == "desconocido", mfv(df$educacion))
df$mora <- replace_na(df$mora, mfv(df$mora))
```

::: {.callout-note}
Nótese que en la columna `educacion` imputamos también sobre las celdas que contienen `"desconocido"`, ya que, para propósitos de este proyecto, representan exactamente lo mismo que un `NA`: el dato no se conoce.
:::

Esta imputación no se realiza en `adq_ahorro` por dos razones:

1. `adq_ahorro` en realidad no tiene datos faltantes.
2. `adq_ahorro` es la variable dependiente del análisis. Queremos encontrar cómo se relaciona con el resto de variables que tenemos, así que no sería de ayuda que tenga datos no reales.

##### Variables numéricas

Para las variables numéricas, consideramos dos métodos de imputación: la **media** y la **mediana**. La selección de la medida a usar para imputar los datos faltantes se hará según el coeficiente de variación.

```{r}
# Esta función calcula el coeficiente de variación de `x`
# ignorando los NAs
cvs <- apply(df %>% select(edad, balance, campana), 2, cv)
cvs
```

El criterio que usaremos es el siguiente:

- Si $\text{CV} < 30\%$, entonces se imputará la **media**, ya que los datos son homogéneos.
- Si $\text{CV} \geq 30\%$, entonces se imputará la **mediana**, ya que los datos se inclinan más hacia ser heterogéneos.

Realizamos este criterio con el objetivo de imputar la medida que mejor represente a cada variable: sabemos que la media es más representativa cuando la dispersión es baja, mientras que, caso contrario, la mediana es más representativa.

Además, si la variable imputada debe ser discreta, el valor de reemplazo se redondea al entero más cercano.

```{r}
for (colname in names(cvs)) {
  x <- df[[colname]]

  x_mean = mean(x, na.rm = TRUE)
  x_median = median(x, na.rm = TRUE)

  # Si CV < 0.3, usar la media; sino, la mediana
  replace_value <- ifelse(cvs[[colname]] < 0.3, x_mean,  x_median)

  if (is.discrete(x))
    replace_value <- round(replace_value)

  df[[colname]] <- replace_na(x, replace_value)
}
```

#### Eliminación de observaciones

La particularidad de la columna `pdias` de poder incluir valores `-1` (nulos) podría dificultar la decisión sobre qué valor imputar a sus datos faltantes. Sin embargo, en esta base de datos particular, `pdias` sólo tiene un valor faltante, por lo que podemos optar por simplemente eliminar dicha observación completamente.

```{r}
df <- df %>% filter(!is.na(df$pdias))
```

### Comprobaciones finales

#### Búsqueda de datos atípicos

Para las variables numéricas, es prudente comprobar que la data no salga de rangos realistas (no debería haber alguna edad, por ejemplo, de 200 años).

```{r}
summary(df %>% select(edad, balance, campana, pdias))
```

La columna `edad` presenta un rango aceptable: de `r min(df$edad)` a `r max(df$edad)` años.

La columna `balance`, por su máximo, podría levantar sospechas. Sin embargo, un diagrama de caja ayuda a visualizar que la mayoría de datos se encuentran alrededor de la mediana: `r median(df$edad)` euros.

```{r}
boxplot(df$balance, main = "Balance promedio anual")
```

Se aprecia que el valor máximo de `balance` es un valor atípico, y considerando lo alejado que está del resto, consideramos que es completamente posible y no debería ser eliminado.

La columna `campana` también podría levantar sospechas, pero su diagrama de caja nos facilita una conclusión similar a la anterior:

```{r}
boxplot(df$campana, main = "Número de contactos realizados durante la campaña")
```

El máximo de `campana`, aunque es comparablemente alto al resto, es posible en la vida real.

Finalmente, el `pdias` se debe hacer por separado ya que, como muestra su `summary`, está tomando en cuenta a los `-1`s, los cuales, más que un valor numérico real, son un código para un valor "nulo".

Por ello, conviene hacer un `summary` de `pdias` ignorando sus valores `-1`:

```{r}
summary(df$pdias[df$pdias != -1])
```

Ocurre un caso similar a los anteriores.

```{r}
boxplot(df$pdias, main = "Días desde el último contacto al cliente")
```

La mayoría de los datos de `pdias` se encuentran alrededor de la mediana, `r median(df$pdias[df$pdias != -1])`, mientras que los más altos o bien son pocos, o en cualquier caso son posibles en la vida real.

#### Consistencia de las variables categóricas

Finalmente, es preciso comprobar que las variables categóricas tienen valores consistentes. Por ejemplo, la columna `estciv`, ya que contiene al menos los valores `"married"`, `"single"` y `"divorced"`, no debería contener versiones alternativas de estos, como por ejemplo `"Married"` o `"SINGLE"`.

Podemos comprobar los valores presentes en cada una de estas variables con la función `unique`:

```{r}
apply(df %>% select(estciv, educacion, mora, adq_ahorro), 2, unique)
```

De esta manera, podemos comprobar que las variables categóricas tienen valores consistentes.

### Resultado final

Mostramos a continuación un vistazo al resultado de la base de datos tras la limpieza:

```{r}
summary(df)
kable(df[1:12, ])
```

Además, podemos comprobar que está libre de datos faltantes:

```{r}
colSums(is.na(df))
```

## Organización/visualización de datos y análisis descriptivo

En esta sección, presentamos algunas visualizaciones de las variables pertinentes a cada objetivo planteado.

### Vista general

```{r}
# Esta función imprime información relevante sobre una columna
full_summary <- function(x) {
  print(summary(x))

  if (class(x) == "numeric") {
    cat("Rango:", round(ran(x), 2), "\n")
    cat("IQR:", round(IQR(x), 2), "\n")
    cat("SD:", round(sd(x), 2), "\n")
    cat("CV:", round(cv(x), 2), "\n")
    cat("Moda:", round(mfv(x), 2), "\n")
  } else {
    freqs <- table(x)
    rel_freqs <- prop.table(freqs)
    full_table <- rbind(absolute = freqs, relative = round(rel_freqs, 2))

    cat("\n")
    cat("Frecuencias:\n")
    print(full_table)
    cat("\n")
    cat("Moda:", mfv(x), "\n")
  }
}
```

#### Balance

Aunque podríamos graficar primero un histograma, el siguiente diagrama de caja muestra por qué no sería muy útil:

```{r}
boxplot(df$balance, main = "Diagrama de caja del balance")
```

Como `balance` tiene una cantidad considerable de datos atípicos, conviene también graficar únicamente los datos dentro del rango intercuartílico para visualizar el "montón" principal de datos.

```{r}
filter_outliers <- function(x, factor = 1.5) {
  iqr = IQR(x)
  lower_bound = quantile(x, 0.25) - factor * iqr
  upper_bound = quantile(x, 0.75) + factor * iqr
  x[x >= lower_bound & x < upper_bound]
}

hist(
  filter_outliers(df$balance, 0),
  main = "Histograma del balance de los encuestados (rango intercuartílico)",
  xlab = "balance"
)
```

En este histograma (que cubre la mayor parte de los datos), podemos observar que la mayoría de balances se encuentran entre los 0 y 500 euros aproximadamente. Además, se puede apreciar visualmente que la moda del balance está entre los 400 y 500 euros.

```{r}
full_summary(df$balance)
```

Estas medidas numéricas complementan las observaciones hechas en las gráficas. El rango de `balance` es muy grande, lo cual se debe a la presencia de los datos atípicos que se pueden ver en el diagrama de caja. Además, es por estos mismos datos que la desviación estándar y el coeficiente de variación son altos, lo cual indica que, para `balance`, la mediana es más representativa.

Esto último se corrobora visualmente de forma muy clara: el montón de los datos está alrededor de los 200-500 euros, lo cual se refleja correctamente en la mediana, al contrario de la media.

#### Mora

<!-- TODO: sacar diagrama -->

```{r}
mora_table <- table(df$mora)
bars <- barplot(
  mora_table,
  col = rainbow(2),
  main = "Estado de mora de los encuestados",
  ylim = c(0, 2400),
  ylab = "Frecuencia"
)
text(bars, mora_table + 100, labels = mora_table)
```

Claramente, podemos observar que muy pocos de los encuestados tienen mora. Esto lo podemos precisar más a detalle con las medidas numéricas de la variable:

```{r}
full_summary(df$mora)
```

Más precisamente, sólo el `r 100 * round(sum(df$mora == "si") / length(df$mora), 2)`% de los encuestados tienen mora pendiente.

Sin embargo, esta baja frecuencia no necesariamente significa que la variable no tendrá aporte en el análisis.

#### Edad

Un histograma puede ofrecer un vistazo a la distribución de los datos:

```{r}
hist(
  df$edad,
  main = "Histograma de la edad de los encuestados",
  xlab = "Edad (años)",
  ylab = "Frecuencia"
)
```

Podemos observar que existe una considerable acumulación de datos alrededor de la marca de 35 años.

También podemos darle un vistazo a las medidas numéricas de `edad`:

```{r}
full_summary(df$edad)
```

Como se puede observar, el rango de `edad` (entre `r min(df$edad)` y `r max(df$edad)` años) es aceptable y realista. Además, la mayoría de los datos se encuentran entre los `r quantile(df$edad, 0.25, type = 3)` y `r quantile(df$edad, 0.75, type = 3)` años (el rango intercuartílico), lo cual tiene sentido realísticamente.

Además, el coeficiente de variación es menor a 30%, por lo que:

1. Los datos tienen dispersión baja.

2. Podemos tomar a la media como la medida representativa del conjunto (aunque igual está cerca a la mediana, en cualquier caso).

Además, aunque no es una medida tan representativa de esta variable, la moda de `r mfv(df$edad)` años que presenta `edad` confirma numéricamente el pico del histograma que vimos anteriormente.

#### Estado civil

Podemos observar las frecuencias relativas de cada estado civil mediante un gráfico circular.

```{r}
estciv_table <- table(df$estciv)
labels <- paste0(round(100 * estciv_table / sum(estciv_table), 2), "%")

colors = rainbow(length(estciv_table))
pie(estciv_table, labels = labels, col = colors, main = "Porcentajes de estado civil en los encuestados")
legend("topleft", legend = c("Divorciado", "Casado", "Soltero"), fill = colors)
```

Esto nos permite ver que la mayoría de encuestados están casados (y la segunda mayoría están solteros), aunque no nos permite concluir mucho más.

Este gráfico se puede ver de forma numérica si construimos la tabla de frecuencias (absoluta y relativa) de `estciv`:

```{r}
full_summary(df$estciv)
```

#### Educación

<!-- TODO: educación -->

#### Campaña

Al igual que en `balance`, un diagrama de caja muestra por qué un histograma regular de esta variable no es tan informativo:

```{r}
boxplot(df$campana)
```

Nuevamente parece conveniente graficar un subconjunto relevante de los datos. En este caso, basta con dejar afuera a los datos atípicos.

```{r}
# Usaremos esta función para filtrar datos fuera de un cierto rango
filter_outliers <- function(x, factor = 1.5) {
  iqr = IQR(x)
  lower_bound = quantile(x, 0.25) - factor * iqr
  upper_bound = quantile(x, 0.75) + factor * iqr
  iqr_balances = x[x >= lower_bound & x < upper_bound]
}
```

Es curioso notar la presencia de los datos atípicos en este diagrama. La gran mayoría de datos de `campana` no pasan de los 5 contactos previos, y sin embargo también hay algunos datos atípicos que llegan hasta los 30 e incluso 50 contactos.

Sin embargo, resulta que el subconjunto que vamos a graficar sólo tiene `r length(unique(filter_outliers(df$campana)))` valores únicos, así que conviene un gráfico de barras.

```{r}
campana_2_table <- table(filter_outliers(df$campana))

barplot(
  campana_2_table,
  main = "Gráfico de barras de campaña (sin atípicos)",
  xlab = "Número de contactos (campaña)",
  ylab = "Frecuencia"
)
```

Con respecto a las medidas numéricas, `campana` produce lo siguiente:

```{r}
full_summary(df$campana)
```

Podemos notar que el rango (`r ran(df$campana)` contactos) es muy elevado en comparación al rango intercuartílico (`r IQR(df$campana)` contactos). Esto confirma los gráficos anteriores: la gran mayoría de datos de `campana` yacen alrededor de `r quantile(df$campana, 0.25, type = 3)` y `r quantile(df$campana, 0.75, type = 3)` días. Sólo hay algunos datos atípicos, los cuales escapan drásticamente ese rango. Además, es debido a estos datos atípicos tan altos que el coeficiente de variación de `campana` resulta mayor incluso al $100\%$.

Como nota adicional, se observa que la mayoría de encuestados sólo habían tenido 1 contacto previo.

#### pdias

En el caso de `pdias`, tenemos que considerar la presencia del `-1`. Antes de analizar

```{r}
colors <- rainbow(2)
pdias_table <- table(df$pdias != -1)
labels <- paste0(round(100 * pdias_table / sum(pdias_table), 2), "%")

pie(
  pdias_table,
  main = "Clientes que fueron contactados desde alguna campaña",
  labels = labels,
  col = colors
)
legend("topleft", legend = c("Contacto no realizado", "Contacto realizado"), fill = colors)
```

Claramente, podemos observar que la mayoría de clientes no han sido previamente contactados en una campaña (es decir, tienen `-1` como entrada en `pdias`).

Sin embargo, nos podemos fijar numéricamente en los clientes que sí fueron contactados (es decir, los que tienen una entrada diferente de `-1`).

```{r}
pdias_nn <- df$pdias[df$pdias != -1]
hist(
  pdias_nn,
  breaks = 25,
  main = "Histograma de pdias (datos no nulos)",
  xlab = "Cantidad de días desde el último contacto",
  ylab = "Frecuencia"
)
```

Podríamos analizar las medidas numéricas de `pdias`, pero no sería muy útil. A lo mucho, puede ser de utilidad confirmar mediante la moda que la mayoría de clientes no fueron contactados:

```{r}
mfv(df$pdias)
```

Podemos notar que, como se espera, la moda de `pdias` es `r mfv(df$pdias)`.

Surgen medidas más útiles cuando nos concentramos únicamente en los valores no nulos de `pdias`:

```{r}
full_summary(pdias_nn)
```

Aunque la desviación estándar y el coeficiente de variación no son tan altos como en las otras variables, siguen siendo moderados. En particular, el CV muestra que la mediana también es una medida mejor representativa de los valores no nulos de `pdias`.

### Vista por objetivo

#### Objetivo 1 (balance, mora)

> Analizar la relación entre el estado financiero de un cliente (`balance`, `mora`) y su predisposición a aceptar una cuenta de ahorro.

Podemos realizar comparaciones con la variable relacionada a la adquisición de la cuenta de ahorro.

```{r}
boxplot(
  df$balance ~ df$adq_ahorro,
  ylim=c(0,4000),
  xlab="Adquisición de la cuenta de ahorro (0 = no, 1 = sí)",
  ylab="Balance",
  main="Diagrama de caja del balance",
  col = rainbow(length(unique(df$adq_ahorro)))
)
```

```{r}
df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(balance),
    q1 = quantile(balance, 0.25, type = 3),
    mediana = median(balance),
    q3 = quantile(balance, 0.75, type = 3),
    moda = mfv(balance),
    cv = cv(balance),
    max = max(balance),
    min = min(balance),
    rango = ran(balance),
    sd = sd(balance),
  )
```

Aunque $Q_1$ y la mediana se mantengan bastante similares, $Q_3$ es visiblemente mayor para las personas que sí adquirieron la cuenta de ahorros. Además, la desviación estándar es considerablemente mayor para los casos donde sí adquirieron la cuenta.

<!-- TODO: poner info general sobre la mora aqui -->

Ahora comparando con la mora, realizamos una tabla de doble entrada para comparar las dos variables dicotomicas:

```{r}
tabla_doble_entrada <- prop.table(table(df$adq_ahorro, df$mora), margin=2)
round(100 * tabla_doble_entrada, 2)
```

```{r}
tabladf <- as.data.frame.matrix(tabla_doble_entrada)

data_long <- pivot_longer(tabladf, cols = c(si,no), names_to = "Mora", values_to = "Porcentaje")
data_long$Group <- rep(c("0", "1"), each = 2)


ggplot(data_long, aes(x = Mora, y = Porcentaje, fill = Group)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.2f%%", Porcentaje * 100)), 
            position = position_stack(vjust = 0.5), size = 4) +
  scale_fill_manual(values = c("skyblue", "lightcoral")) +
  labs(x = "Mora", y = "Porcentaje", fill = "Adquisición (0 = no, 1 = sí)") +
  scale_y_continuous(labels = scales::percent)
```

Ahora pidiendo apreciar un gráfico más proporcional, podemos observar que hay una proporción *ligeramente* mayor de personas que aceptan la cuenta de ahorros cuando si cuentan con mora.

#### Objetivo 2 (edad, estado civil)

> Identificar el impacto de las características demográficas (`edad`, `estciv`) en la decisión de adquirir una cuenta de ahorro.

Un diagrama de caja nos puede permitir comparar posibles diferencias entre las edades de quienes adquirieron una cuenta de ahorro de quienes no.

```{r}
boxplot(
  df$edad ~ df$adq_ahorro,
  main = "Diagrama de caja de la edad de los encuestados",
  xlab = "Adquisición de la cuenta de ahorro (0 = no, 1 = sí)", ylab = "Edad (años)",
  col = rainbow(length(unique(df$adq_ahorro)))
)
```

Una observación interesante de este gráfico es que muestra cómo la mayoría de encuestados con edades atípicas (es decir, las edades por encima de alrededor de 70) adquirieron la cuenta de ahorro.

```{r}
df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(edad),
    mediana = median(edad),
    moda = mfv(edad),
    cv = cv(edad),
    max = max(edad),
    min = min(edad),
    rango = ran(edad),
    sd = sd(edad),
  )
```

Nuevamente, resulta útil realizar una comparación entre quienes adquirieron la cuenta de ahorro y quienes no lo hicieron. Para ello, nos conviene usar un diagrama de mosaico.

```{r}
data <- table(df$adq_ahorro, df$estciv)
mosaicplot(data, main = "Diagrama de mosaico", color = TRUE)
```

Sin embargo, parece que, a primera vista, no hay una diferencia significativa entre el estado civil de los que adquirieron la cuenta de ahorro y quienes no. Pese a ello, podemos notar que, entre las personas que sí adquirieron la cuenta, hay *ligeramente* menos individuos casados (divorciados, en su lugar) en comparación a quienes no la adquirieron.

Otro vistazo interesante a estas variables es analizar diagramas de caja de las edades para cada estado civil.

```{r}
boxplot(
  df$edad ~ df$estciv,
  main = "Diagrama de caja de edades por estado civil",
  col = rainbow(length(unique(df$estciv))),
  xlab = "Estado civil",
  ylab = "Edad (años)"
)
```

Podemos observar de forma notoria que las personas solteras tienden a tener edades menores que las personas casadas o divorciadas, lo cual tiene sentido si consideramos que, intuitivamente, una persona mayor tiene más probabilidad de estar casada que una persona más joven.

Además, se puede observar que la caja correspondiente a los individuos divorciados está muy ligeramente movida un poco más arriba que la de los individuos casados. Es una diferencia extremadamente pequeña, pero igualmente tiene sentido.

#### Objetivo 3 (educación)

> Identificar un posible patrón en el nivel de educación (`educacion`) de las personas que aceptan abrir una cuenta de ahorro.

Podemos usar un gráfico de mosaico para visualizar la relación entre `educacion` y `adq_ahorro`:

```{r}
# Crear tabla de datos
data <- table(df$educacion, df$adq_ahorro)

# Gráfico de mosaico
mosaicplot(data,
           main = "Relación entre Nivel Educativo y Decisión de Ahorro",
           xlab = "Nivel Educativo",
           ylab = "Decisión de Ahorro (0 = No, 1 = Sí)",
           color = c("tomato", "steelblue"))
```

**Figura 2.** Mosaico de la relación entre nivel educativo y decisión de abrir una cuenta de ahorro.

Podemos observar que, a grandes rasgos, el nivel educativo de secundaria es el más propenso a adquirir cuentas de ahorro, aunque por un margen relativamente pequeño. En ese mismo sentido, es el nivel educativo de primaria el que menos adquisiciones de cuentas de ahorro tiene.

Sin embargo, es relevante notar que el nivel de educación terciario no sea el predominante en la adquisición de ahorro, ya que, intuitivamente, una persona con educación superior debería estar informada de mejores prácticas de finanzas. Sin embargo, esto se podría explicar si consideráramos que estas personas podrían haber rechazado la cuenta por ya contar con una en otro banco.

#### Objetivo 4 (campaña)

> Evaluar el efecto de las variables relacionadas con la interacción con el cliente (`campana`) en la decisión de adquirir una cuenta de ahorro.

```{r}
ggplot(df, aes(x = factor(adq_ahorro), y = campana, fill = factor(adq_ahorro))) +
  geom_boxplot(alpha = 0.9) +
  labs(
    title = "Boxplots de campana por adquisición de cuenta de ahorro",
    x = "Adquirió cuenta (1 = Sí, 0 = No)",
    y = "Número de contactos (campana)",
    fill = "Adquirió cuenta"
  ) +
  theme_light()
```

```{r}
resumen_campana <- df %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(campana),
    mediana = median(campana),
    moda = mfv(campana),
    cv = cv(campana),
    max = max(campana),
    min = min(campana),
    rango = ran(campana),
    sd = sd(campana),
  )

kable(resumen_campana)
```

Podemos observar que la mayoría de medidas en ambos grupos son similares (en particular, la media, mediana y la moda). Sin embargo, los sujetos que sí adquirieron la cuenta de ahorro presentan varios datos atípicos más que quienes no la adquirieron, lo que causa una mayor desviación estándar y coeficiente de variación.

También podemos observar que el número de contactos realizados es similar en promedio para ambos grupos, pero quienes adquirieron la cuenta muestran mayor dispersión, rango y un valor máximo más alto. Esto sugiere que, aunque el número promedio de contactos no varía mucho, en algunos casos, un mayor número de contactos parece estar relacionado con la adquisición de la cuenta.

#### Objetivo 5 (pidas)

> Identificar el tiempo posterior promedio de la última llamada a los clientes (`pdias`) antes de aceptar abrir una cuenta de ahorro.

En primer lugar, podemos observar cuántos valores nulos (`-1`) tiene `pdias`:

```{r}
sum(df$pdias == -1)
```

Esta es una cantidad considerablemente grande (correspondiente al `r round(100 * sum(df$pdias == -1) / length(df$pdias), 2)`% de las observaciones). Quiere decir que el `r round(100 * sum(df$pdias == -1) / length(df$pdias), 2)`% de los encuestados no han sido contactados en alguna campaña.

Por esta presencia de `-1`s, analizaremos esta variable en dos partes.

```{r}
df_aux <- df[df$pdias != -1, ]
##convertir esto a un histograma doble
boxplot(
        df_aux$pdias ~ df_aux$adq_ahorro,
        names = c("No", "Si"),
        col = c("blue", "green"), 
        main = "Si fueron contactados", 
        ylab = "Cantidad de personas", 
        xlab = "Adquirieron")
```

```{r}
df %>% 
  filter(pdias != -1) %>% 
  group_by(adq_ahorro) %>%
  summarise(
    media = mean(pdias),
    q1 = quantile(pdias, 0.25, type = 3),
    mediana = median(pdias),
    q3 = quantile(pdias, 0.75, type = 3),
    moda = mfv(pdias),
    cv = cv(pdias),
    max = max(pdias),
    min = min(pdias),
    rango = ran(pdias),
    sd = sd(pdias),
  )
```

Con las gráficas y las medidas que vemos aquí, podemos notar que, en general, las personas que adquieren la cuenta de ahorro tienden a hacerlo en un número ligeramente menor de días tras el último contacto que las personas que no la adquieren. La diferencia no es demasiado significativa, pero está presente.

Además, los datos atípicos presentes en las personas que sí adquirieron (los cuales a primera vista parecen contradecir la observación anterior) se pueden explicar como un caso especial: pueden haber sido personas que simplemente no adquirieron la cuenta debido a una campaña particular, sino que mucho tiempo más adelante la pudieron haber adquirido por otras razones.

Por otro lado, podemos analizar los porcentajes de adquisición entre los `r sum(df$pdias == 1)` encuestados que nunca fueron contactados:

```{r}
df_aux_2 <- df[df$pdias == -1, ]
pdias_table <- table(df_aux_2$adq_ahorro)

colors <- rainbow(2)
pdias_table <- table(df$pdias != -1)
labels <- paste0(round(100 * pdias_table / sum(pdias_table), 2), "%")

pie(
  pdias_table,
  main = "Adquisición en los clientes no contactados previamente",
  labels = labels,
  col = colors
)
legend("topleft", legend = c("Sí adquirió", "No adquirió"), fill = colors)
```

Es notorio que, como muestra este gráfico, la mayoría de los clientes que no fueron contactados previamente sí adquirieron la cuenta de ahorro. Considerando que, de hecho, los clientes no contactados previamente ya son la mayor parte de la muestra, sería apropiado concluir que se le debe dar una gran importancia a la primera impresión que el banco le da al cliente. El gráfico de cajas anterior complementa esta idea: los datos de los clientes que sí habían sido contactados previamente, más bien, se dispersan.
